import type { IR, IRSchema, IROperation, IRProperty, IRSchemaRef } from '../ir'

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1)
}

function defaultValueForType(type: string): string {
  switch (type) {
    case 'number': return '1'
    case 'boolean': return 'true'
    case 'string': return "'string'"
    default: return "'unknown'"
  }
}

function mockPropertyValue(prop: IRProperty, schemas: IRSchema[]): string {
  if (prop.ref) {
    const refName = prop.ref.split('/').pop()
    return `mock${refName}`
  }
  if (prop.isArray) {
    if (prop.itemType) return `[${defaultValueForType(prop.itemType)}]`
    return '[]'
  }
  if (prop.enumValues && prop.enumValues.length > 0) {
    return `'${prop.enumValues[0]}'`
  }
  return defaultValueForType(prop.type)
}

function refToSchemaName(ref: string | null): string | null {
  if (!ref) return null
  return ref.split('/').pop() ?? null
}

function generateSchemaMock(schema: IRSchema, allSchemas: IRSchema[]): string {
  const lines: string[] = []
  lines.push(`export const mock${schema.name}: ${schema.name} = {`)
  for (const prop of schema.properties) {
    lines.push(`  ${prop.name}: ${mockPropertyValue(prop, allSchemas)},`)
  }
  lines.push('}')
  return lines.join('\n')
}

function generateResponseMock(op: IROperation): string | null {
  if (!op.responseSchema) return null

  const name = `mock${capitalize(op.operationId)}Response`

  if (op.responseSchema.isArray) {
    const itemRef = refToSchemaName(op.responseSchema.itemRef)
    if (itemRef) {
      return `export const ${name}: ${itemRef}[] = [mock${itemRef}]`
    }
    return `export const ${name}: unknown[] = []`
  }

  const ref = refToSchemaName(op.responseSchema.ref)
  if (ref) {
    return `export const ${name}: ${ref} = mock${ref}`
  }

  return null
}

function generateMocks(ir: IR): string {
  const parts: string[] = []
  const usedTypes = new Set<string>()

  parts.push('/* eslint-disable */')
  parts.push('/* This file is auto-generated by apigen. Do not edit. */')
  parts.push('')

  for (const schema of ir.schemas) {
    usedTypes.add(schema.name)
  }

  if (usedTypes.size > 0) {
    const importLine = `import type { ${[...usedTypes].join(', ')} } from './types'`
    parts.push(importLine)
    parts.push('')
  }

  for (const schema of ir.schemas) {
    parts.push(generateSchemaMock(schema, ir.schemas))
    parts.push('')
  }

  for (const op of ir.operations) {
    const responseMock = generateResponseMock(op)
    if (responseMock) {
      parts.push(responseMock)
      parts.push('')
    }
  }

  return parts.join('\n')
}

export { generateMocks }
