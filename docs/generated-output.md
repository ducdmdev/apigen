# Generated Output Reference

This document is a file-by-file walkthrough of everything apigen produces. After running `apigen generate -i spec.yaml`, you get a single output directory (default: `./src/api/generated/`) containing five files.

## Output Directory Structure

```
<output-dir>/
  types.ts                 # TypeScript interfaces for schemas and params
  hooks.ts                 # TanStack Query hooks (useQuery / useMutation)
  mocks.ts                 # Static mock constants for every schema and response
  test-mode-provider.tsx   # React context to toggle hooks between real and mock data
  index.ts                 # Barrel re-exports
```

Every file begins with these two lines:

```ts
/* eslint-disable */
/* This file is auto-generated by apigen. Do not edit. */
```

---

## types.ts

**Purpose:** Declare TypeScript interfaces for every OpenAPI schema and every set of operation parameters.

### Schema interfaces

For each object defined under `components.schemas` in the spec, apigen emits a 1:1 interface. The interface name matches the schema name exactly.

**Naming convention:** The schema key in the OpenAPI spec becomes the interface name verbatim. Properties keep their original names; no case transformation is applied.

**Type mapping:**

| OpenAPI type | TypeScript type |
|---|---|
| `string` (any format) | `string` |
| `integer`, `number` | `number` |
| `boolean` | `boolean` |
| `array` (of T) | `T[]` |
| `object` | `object` |
| `$ref: '#/components/schemas/Foo'` | `Foo` |
| anything else | `unknown` |

**Optional vs required:** A property is marked optional (`?`) unless it appears in the schema's `required` array.

#### Example

Given this spec fragment:

```yaml
components:
  schemas:
    User:
      type: object
      required: [id, email]
      properties:
        id:
          type: integer
        email:
          type: string
        name:
          type: string
        roles:
          type: array
          items:
            type: string
        profile:
          $ref: '#/components/schemas/Profile'
```

apigen produces:

```ts
export interface User {
  id: number
  email: string
  name?: string
  roles?: string[]
  profile?: Profile
}
```

### Param interfaces

For each operation that has at least one path or query parameter, apigen emits a `<OperationId>Params` interface. The operation ID is capitalized (first letter uppercased) before appending `Params`.

**Naming convention:** `capitalize(operationId) + "Params"`. For example, `getUser` becomes `GetUserParams`, `listItems` becomes `ListItemsParams`.

Path params and query params are merged into the same interface. Each param's `required` flag from the spec controls whether the property is optional.

#### Example

Given:

```yaml
paths:
  /users/{userId}:
    get:
      operationId: getUser
      parameters:
        - name: userId
          in: path
          required: true
          schema:
            type: integer
        - name: include
          in: query
          required: false
          schema:
            type: string
```

apigen produces:

```ts
export interface GetUserParams {
  userId: number
  include?: string
}
```

---

## hooks.ts

**Purpose:** Generate one TanStack Query hook per operation. GET operations become `useQuery` hooks; POST, PUT, PATCH, and DELETE operations become `useMutation` hooks.

### Imports

The file imports from four sources:

```ts
import { useQuery, type UseQueryOptions } from '@tanstack/react-query'
import { useMutation, type UseMutationOptions } from '@tanstack/react-query'
import { useApiTestMode } from './test-mode-provider'
import { mockGetUserResponse, mockCreateUserResponse, /* ... */ } from './mocks'
import type { User, GetUserParams, CreateUserBody, /* ... */ } from './types'
```

Only the imports actually needed are included. If there are no GET operations, `useQuery` and `UseQueryOptions` are omitted. Likewise for mutations.

### apiFetch helper

A minimal fetch wrapper is emitted at the top of the file:

```ts
function apiFetch<T>(path: string, init?: RequestInit): Promise<T> {
  return fetch(path, {
    headers: { 'Content-Type': 'application/json' },
    ...init,
  }).then(res => {
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`)
    return res.json() as Promise<T>
  })
}
```

It sets `Content-Type: application/json` by default and throws on non-2xx responses. All generated hooks call this function internally.

### useQuery hooks (GET operations)

**Hook naming:** `use` + `capitalize(operationId)`. For example, `listUsers` becomes `useListUsers`.

**Query keys:** Built from the URL path segments. Static segments become string literals; path parameters become `params.<name>` references.

| Path | Query key |
|---|---|
| `/users` | `['users']` |
| `/users/{userId}` | `['users', params.userId]` |
| `/orgs/{orgId}/repos/{repoId}` | `['orgs', params.orgId, 'repos', params.repoId]` |

**Test mode integration:** Every hook reads `useApiTestMode()`. When `testMode` is `true`, the `queryFn` returns `Promise.resolve(mockResponse)` instead of calling `apiFetch`.

**Query parameters:** If the operation has query params, the hook builds a `URLSearchParams` object at call time. Only params that are not `undefined` are appended.

**Options passthrough:** The hook accepts an optional `options` argument typed as `Omit<UseQueryOptions<ResponseType>, 'queryKey' | 'queryFn'>`, so callers can pass `enabled`, `staleTime`, `refetchInterval`, etc.

#### Annotated example (GET without query params)

```ts
// Generated from: GET /users/{userId}  operationId: getUser
export function useGetUser(params: GetUserParams, options?: Omit<UseQueryOptions<User>, 'queryKey' | 'queryFn'>) {
  const { enabled: testMode } = useApiTestMode()

  return useQuery({
    queryKey: ['users', params.userId],
    queryFn: testMode
      ? () => Promise.resolve(mockGetUserResponse)
      : () => apiFetch<User>(`/users/${params.userId}`),
    ...options,
  })
}
```

#### Annotated example (GET with query params)

```ts
// Generated from: GET /users  operationId: listUsers
export function useListUsers(params: ListUsersParams, options?: Omit<UseQueryOptions<User[]>, 'queryKey' | 'queryFn'>) {
  const { enabled: testMode } = useApiTestMode()

  return useQuery({
    queryKey: ['users'],
    queryFn: testMode
      ? () => Promise.resolve(mockListUsersResponse)
      : () => {
      const searchParams = new URLSearchParams()
      if (params.page !== undefined) searchParams.set('page', String(params.page))
      if (params.limit !== undefined) searchParams.set('limit', String(params.limit))
      const queryString = searchParams.toString()
      const url = queryString ? `/users?${queryString}` : '/users'
      return apiFetch<User[]>(url)
    },
    ...options,
  })
}
```

### useMutation hooks (POST / PUT / PATCH / DELETE)

**Hook naming:** Same convention -- `use` + `capitalize(operationId)`.

**Mutation function:** The `mutationFn` accepts a `body` argument typed to the request body's `$ref` schema (or `unknown` if none). It calls `apiFetch` with the appropriate HTTP method and `JSON.stringify(body)`.

**Path params:** If the operation has path params, a `params` argument is accepted.

**Test mode integration:** Same pattern as queries -- when test mode is enabled, `mutationFn` returns `Promise.resolve(mockResponse)`.

**Options passthrough:** Accepts `Omit<UseMutationOptions<ResponseType, Error, BodyType>, 'mutationFn'>`.

#### Annotated example

```ts
// Generated from: POST /users  operationId: createUser
export function useCreateUser(options?: Omit<UseMutationOptions<User, Error, CreateUserInput>, 'mutationFn'>) {
  const { enabled: testMode } = useApiTestMode()

  return useMutation({
    mutationFn: testMode
      ? () => Promise.resolve(mockCreateUserResponse)
      : (body: CreateUserInput) => apiFetch<User>('/users', {
          method: 'POST',
          body: JSON.stringify(body),
        }),
    ...options,
  })
}
```

---

## mocks.ts

**Purpose:** Provide deterministic, static mock data for every schema and every operation response. These constants are imported by `hooks.ts` for test mode.

### Schema mock constants

For each schema in the IR, apigen emits a `mock<SchemaName>` constant of that schema's type. Every property gets a sensible default value:

**Default values by type:**

| IR type | Mock value |
|---|---|
| `string` | `'string'` |
| `number` (integer or number) | `1` |
| `boolean` | `true` |
| `array` (of T) | Single-element array, e.g. `[1]` for `number[]`, `['string']` for `string[]` |
| `enum` | First enum value, e.g. `'active'` for `enum: [active, inactive]` |
| `$ref` to another schema | Reference to that schema's mock constant, e.g. `mockProfile` |
| anything else | `'unknown'` |

#### Example

```ts
import type { User, Profile } from './types'

export const mockProfile: Profile = {
  bio: 'string',
  avatarUrl: 'string',
}

export const mockUser: User = {
  id: 1,
  email: 'string',
  name: 'string',
  roles: ['string'],
  profile: mockProfile,
}
```

### Response mock constants

For each operation that has a response schema, apigen emits a `mock<OperationId>Response` constant.

- If the response is a `$ref` to a schema (e.g. `User`), the mock aliases the schema mock: `export const mockGetUserResponse: User = mockUser`
- If the response is an array of `$ref` items, it wraps in an array: `export const mockListUsersResponse: User[] = [mockUser]`
- If the response has no `$ref`, no mock is emitted.

#### Example

```ts
export const mockGetUserResponse: User = mockUser

export const mockListUsersResponse: User[] = [mockUser]

export const mockCreateUserResponse: User = mockUser
```

---

## test-mode-provider.tsx

**Purpose:** A React context provider that lets you toggle all generated hooks between real API calls and mock data, without changing any hook call sites.

### What gets generated

The file contains exactly two exports:

1. **`ApiTestModeProvider`** -- a React context provider component.
2. **`useApiTestMode`** -- a hook that reads the context value.

```tsx
import { createContext, useContext, type ReactNode } from 'react'

interface ApiTestModeContext {
  enabled: boolean
}

const ApiTestModeCtx = createContext<ApiTestModeContext>({ enabled: false })

export function ApiTestModeProvider({
  enabled,
  children,
}: {
  enabled: boolean
  children: ReactNode
}) {
  return (
    <ApiTestModeCtx.Provider value={{ enabled }}>
      {children}
    </ApiTestModeCtx.Provider>
  )
}

export function useApiTestMode(): ApiTestModeContext {
  return useContext(ApiTestModeCtx)
}
```

### How to use it

**In production** -- do nothing. The default context value is `{ enabled: false }`, so all hooks make real `fetch` calls.

**In tests or Storybook** -- wrap your component tree:

```tsx
import { ApiTestModeProvider } from './api/generated'

// In a test file
render(
  <ApiTestModeProvider enabled={true}>
    <YourComponent />
  </ApiTestModeProvider>
)
```

When `enabled` is `true`, every `useQuery` and `useMutation` hook returns mock data immediately (via `Promise.resolve`) instead of hitting the network. This gives you deterministic, synchronous-like behavior in tests with zero network setup.

---

## index.ts

**Purpose:** Barrel file that re-exports everything from the other four modules.

```ts
export * from './types'
export * from './hooks'
export * from './mocks'
export * from './test-mode-provider'
```

This means consumers can import anything from a single path:

```ts
import { useGetUser, User, mockUser, ApiTestModeProvider } from './api/generated'
```
